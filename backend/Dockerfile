# --- Этап 1: Сборка приложения ---
# Используем официальный образ Go в качестве "строительной площадки".
# Он содержит все инструменты для компиляции нашего кода.
FROM golang:1.23.0-alpine AS builder

# Устанавливаем рабочую директорию внутри контейнера.
WORKDIR /app

# Копируем файлы нашего Go-модуля.
COPY go.mod go.sum ./

# Скачиваем все зависимости, указанные в go.mod
RUN go mod download

# Копируем весь остальной исходный код
COPY . .

# Собираем (компилируем) наше приложение.
# -o /dnd-backend говорит компилятору, куда положить результат.
# CGO_ENABLED=0 и -ldflags="-s -w" делают исполняемый файл максимально маленьким и статичным.
RUN CGO_ENABLED=0 GOOS=linux go build -ldflags="-s -w" -o /dnd-backend .

# --- Этап 2: Создание минимального образа для запуска ---
# Используем образ "scratch" - это абсолютно пустой образ, в нем нет ничего.
# Это лучший способ создать минимальный образ.
FROM alpine:3.20

# Аргументы для UID и GID с значениями по умолчанию
ARG TESTER_UID=10001
ARG TESTER_GID=10001

# Создаем группу и пользователя с заданными GID и UID.
# -S: создать системного пользователя, -G: добавить в группу, -u: задать UID
RUN addgroup -g ${TESTER_GID} tester && \
    adduser -S -u ${TESTER_UID} -G tester tester

# Устанавливаем curl, который понадобится для healthcheck
RUN apk --no-cache add curl

# Копируем ТОЛЬКО скомпилированное приложение из этапа "builder".
COPY --from=builder /dnd-backend /dnd-backend

RUN chown tester:tester /dnd-backend
USER tester
# Указываем, что наш контейнер будет слушать порт 8080.
EXPOSE 8080

# Команда, которая будет выполняться при запуске контейнера.
# Запускаем наше скомпилированное приложение.
CMD ["/dnd-backend"]